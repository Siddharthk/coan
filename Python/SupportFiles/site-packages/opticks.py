import _opticks
from code import InteractiveInterpreter
import sys
from StringIO import StringIO
from operator import mul

class StrBufStream:
   def __init__(self):
      self.__buf = ""

   def available(self):
      if self.__buf:
         return len(self.__buf)
      return 0

   def close(self):
      self.__buf = None

   def read(self, count):
      buf = ""
      if count >= len(self.__buf):
         buf,self.__buf = self.__buf,""
      else:
         buf,self.__buf = self.__buf[:count],self.__buf[count:]
      return buf

   def isNonBlocking(self):
      return True

   def write(self, buf, count=None):
      if count is None: count = len(buf)
      if len(buf) <= count:
         self.__buf += buf
         return len(buf)
      self.__buf += buf[:count]
      return count

class PythonInteractiveInterpreter(InteractiveInterpreter):
   def __init__(self):
      self.stdin,self.stdout,self.stderr = None,None,None
      self.buf = ""
      sys.stdout = StringIO()
      InteractiveInterpreter.__init__(self)
      sys.ps1 = ">>> "
      sys.ps2 = "... "

   def getRealStdout(self):
      buf = sys.stdout.getvalue()
      sys.stdout.truncate(0)
      return buf

   def processEvent(self):
      """ Process input and return True if input is complete or incorrect;
          False if input is correct but incomplete
      """
      out = self.getRealStdout()
      if out and self.stdout: self.stdout.write(out, len(out)) # flush stdout
      if not self.stdin: return True # invalid stdin

      buf = self.stdin.read(self.stdin.available())
      inMultiline = self.buf and buf != "\n" # pending input and new input added
      buf = self.buf + buf
      if buf:
         if self.runsource(buf) or inMultiline:
            # Input is correct but incomplete, store the input and prompt with ps2
            self.buf = buf
            out = self.getRealStdout()
            if out and self.stdout: self.stdout.write(out, len (out)) # flush stdout
            if self.stdout: self.stdout.write(sys.ps2, len(sys.ps2))  # prompt
         else:
            # Input is complete or incorrect, clear the input buffer and prompt with ps1
            self.buf = ""
            out = self.getRealStdout()
            if out and self.stdout: self.stdout.write(out, len(out)) # flush stdout
            if self.stdout: self.stdout.write(sys.ps1, len(sys.ps1)) # prompt
            return True
      elif self.buf and self.stdout:
         # Empty input but there is pending input, prompt with ps2
         self.stdout.write(sys.ps2, len(sys.ps2))
      elif self.stdout:
         # Empty input and no pending input, prompt with ps1
         self.stdout.write(sys.ps1, len(sys.ps1))
      return False

   def write(self, data):
      if self.stderr:
         data = str(data)
         self.stderr.write(data, len(data))

class RasterElement(object):
   def __init__(self, name=None):
      self.__de = _opticks.get_data_element("raster", name)
      self.__acc = None

   @property
   def dims(self):
      return self.__de['dims']

   @property
   def name(self):
      return self.__de['name']

   @property
   def interleave(self):
      return self.__de['interleave']

   @property
   def datatype(self):
      return self.dt_conv[self.__de['datatype']]

   def __repr__(self):
      return "<RasterElement [%i,%i,%i] '%s'>" % (self.__de['dims'][0],self.__de['dims'][1],self.__de['dims'][2],self.__de['name'])

   def getData(self, subcube=None):
      self.__acc, a = _opticks.get_raster_data(self.__de, subcube)
      return a

   def newLayer(self, name, arr, type="raster"):
      _opticks.new_raster_from_array(name, arr, type, self.__de)

class Signature(object):
   def __init__(self, name, parent=None):
      if isinstance(parent, RasterElement):
         parent = parent.name
      self.__de = _opticks.get_data_element("signature", name, parent)

   @property
   def name(self):
      return self.__de['name']

   @property
   def dataNames(self):
      return self.__de['dataNames']

   def __repr__(self):
      return "<Signature '%s'>" % self.__de['name']

   def getData(self, name=None):
      return _opticks.get_signature_data(self.__de, name)

def new_view(name, arr):
   _opticks.new_raster_from_array(name, arr, "view")
   return RasterElement(name)
