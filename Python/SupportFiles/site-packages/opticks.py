import _opticks
from code import InteractiveInterpreter
import sys
from StringIO import StringIO
from operator import mul

__doc__ = """Routines and classes for iterfacing with Opticks."""

class StrBufStream:
   def __init__(self):
      self.__buf = ""

   def available(self):
      if self.__buf:
         return len(self.__buf)
      return 0

   def close(self):
      self.__buf = None

   def read(self, count):
      buf = ""
      if count >= len(self.__buf):
         buf,self.__buf = self.__buf,""
      else:
         buf,self.__buf = self.__buf[:count],self.__buf[count:]
      return buf

   def isNonBlocking(self):
      return True

   def write(self, buf, count=None):
      if count is None: count = len(buf)
      if len(buf) <= count:
         self.__buf += buf
         return len(buf)
      self.__buf += buf[:count]
      return count

class PythonInteractiveInterpreter(InteractiveInterpreter):
   def __init__(self):
      self.stdin,self.stdout,self.stderr = None,None,None
      self.buf = ""
      sys.stdout = StringIO()
      InteractiveInterpreter.__init__(self)
      sys.ps1 = ">>> "
      sys.ps2 = "... "

   def getRealStdout(self):
      buf = sys.stdout.getvalue()
      sys.stdout.truncate(0)
      return buf

   def processEvent(self):
      """ Process input and return True if input is complete or incorrect;
          False if input is correct but incomplete
      """
      out = self.getRealStdout()
      if out and self.stdout: self.stdout.write(out, len(out)) # flush stdout
      if not self.stdin: return True # invalid stdin

      buf = self.stdin.read(self.stdin.available())
      inMultiline = self.buf and buf != "\n" # pending input and new input added
      buf = self.buf + buf
      if buf:
         if self.runsource(buf) or inMultiline:
            # Input is correct but incomplete, store the input and prompt with ps2
            self.buf = buf
            out = self.getRealStdout()
            if out and self.stdout: self.stdout.write(out, len (out)) # flush stdout
            if self.stdout: self.stdout.write(sys.ps2, len(sys.ps2))  # prompt
         else:
            # Input is complete or incorrect, clear the input buffer and prompt with ps1
            self.buf = ""
            out = self.getRealStdout()
            if out and self.stdout: self.stdout.write(out, len(out)) # flush stdout
            if self.stdout: self.stdout.write(sys.ps1, len(sys.ps1)) # prompt
            return True
      elif self.buf and self.stdout:
         # Empty input but there is pending input, prompt with ps2
         self.stdout.write(sys.ps2, len(sys.ps2))
      elif self.stdout:
         # Empty input and no pending input, prompt with ps1
         self.stdout.write(sys.ps1, len(sys.ps1))
      return False

   def write(self, data):
      if self.stderr:
         data = str(data)
         self.stderr.write(data, len(data))

class RasterElement(object):
   """Wraps a RasterElement"""
   def __init__(self, name=None):
      """Get a raster element.
         name = The name of the raster element or if None, the primary raster element from the active view.
      """
         
      self.__de = _opticks.get_data_element("raster", name)
      self.__acc = None

   @property
   def dims(self):
      "The dimension vector for the raster element"
      return self.__de['dims']

   @property
   def name(self):
      "The name of the raster element"
      return self.__de['name']

   @property
   def interleave(self):
      "The interleave (BIP, BIL, or BSQ)"
      return self.__de['interleave']

   @property
   def datatype(self):
      "The dataype of the raster element."
      return self.dt_conv[self.__de['datatype']]

   def __repr__(self):
      return "<RasterElement [%i,%i,%i] '%s'>" % (self.__de['dims'][0],self.__de['dims'][1],self.__de['dims'][2],self.__de['name'])

   def getData(self, subcube=None):
      """Get the data from a raster element as a numpy Array.
       subcube = None for all the data or a dictionare containing options rows and bands keys.
                 Each key fromtails a tuple with the start and option end values for the rows of bands.
                 The band key is ignored if the interleave is BIP. If the interleave is not BIP and a row
                 subcube is specified, then a start band must be specificed. The number of bands is 1.
      """
      self.__acc, a = _opticks.get_raster_data(self.__de, subcube)
      return a

   def newLayer(self, name, arr, type="raster"):
      """Create a new layer for the given array.
         name = The name of the layer and corresponding raster element. If this element
                exists, the arr must be the say type and dimensions of the existing element
                and the data will be replaced.
         arr = The numpy Array with the data.
         type = raster, pseudocolor, or threshold
      """
      _opticks.new_raster_from_array(name, arr, type, self.__de)

class Signature(object):
   """An Opticks Signature object."""
   def __init__(self, name, parent=None):
      """Get an existing signature with a specified name and optional parent.
         name = The name of the signature
         parent = The name of the parent data element the parent RasterElement or Signature.
      """
      if isinstance(parent, RasterElement) or isinstance(parent, Signature):
         parent = parent.name
      self.__de = _opticks.get_data_element("signature", name, parent)

   @property
   def name(self):
      "The name of the signature."
      return self.__de['name']

   def __iter__(self):
      "Get the names of different data sets in this signature."
      return iter(self.__de['dataNames'])

   def __contains__(self, item):
      "Is the given data set in this signature?"
      return item in self.__de['dataNames']

   def __repr__(self):
      return "<Signature '%s'>" % self.__de['name']

   def __getitem__(self, name):
      "Get the data for a particular name."
      return _opticks.get_signature_data(self.__de, name)

def new_view(name, arr):
   """Create a new view with the given data.
      name = The name of the new view, new raster element, and new layer.
      arr = The numpy Array with the data.
   """
   _opticks.new_raster_from_array(name, arr, "view")
   return RasterElement(name)
